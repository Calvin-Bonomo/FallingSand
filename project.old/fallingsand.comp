#version 430

layout(local_size_x=32, local_size_y=32) in;

layout(r32ui) uniform uimage2D buf;
uniform uint iteration;
uniform ivec2 simSize;

const uint STATIC_MASK = 0x1u;
const uint SPREADING_MASK = 0x2u;
const uint LIFTING_MASK = 0x4u;

const uint AIR = 0x00000000;
const uint WALL = 0x01007f01;
const uint SAND = 0x00000f02;
const uint WATER = 0x02000e03;
const uint STEAM = 0x04008004;

uint getFlag(uint particle) {
  return (particle >> 24) & 0xffu;
}

uvec4 getFlags(uvec4 particles) {
  return uvec4(getFlag(particles.x), getFlag(particles.y), getFlag(particles.z), getFlag(particles.w));
}

uint getMaterial(uint particle) {
  return particle & 0xffu;
}

uvec4 getMaterials(uvec4 materials) {
  return uvec4(getMaterial(materials.x), getMaterial(materials.y), getMaterial(materials.z), getMaterial(materials.w));
}

int getDensity(uint particle) {
  int density = int(particle >> 8) & 0xff;
  int signedness = (density & 0x80) << 24;
  density &= 0x7f;
  return density | signedness;
}

ivec4 getDensities(uvec4 particles) {
  return ivec4(getDensity(particles.x), getDensity(particles.y), getDensity(particles.z), getDensity(particles.w));
}

uvec4 getNeighborhood(ivec2 pos) {
  uvec4 data = uvec4(imageLoad(buf, pos).r, 0, 0, 0);
  data.y = imageLoad(buf, pos + ivec2(1,  0)).r;
  data.z = imageLoad(buf, pos + ivec2(0, -1)).r;
  data.w = imageLoad(buf, pos + ivec2(1, -1)).r;
  return data;
}

uvec4 simulateNeighborhood(uvec4 particles) {
  ivec4 density = getDensities(particles);
  uvec4 flags = getFlags(particles);
  bool falling = false;

  if ((flags.x & STATIC_MASK) == 0) {
    if (density.x > density.z) {
      particles = particles.zyxw;
      density = density.zyxw;
      falling = true;
    } 
    else if (density.x > density.w) {
      particles = particles.wyzx;
      density = density.wyzx;
      falling = true;
    }
  } 
  if ((flags.y & STATIC_MASK) == 0) {
    if (density.y > density.w) {
      particles = particles.xwzy;
      density = density.xwzy;
      falling = true;
    } 
    else if (density.y > density.z) {
      particles = particles.xzyw;
      density = density.xzyw;
      falling = true;
    }
  }
  if (!falling) {
    if ((flags.x & SPREADING_MASK) != 0 && density.x > density.y && (flags.y & STATIC_MASK) == 0) {
      particles = particles.yxzw;
      density = density.yxzw;
    }
    else if ((flags.y & SPREADING_MASK) != 0 && density.y > density.x && (flags.x & STATIC_MASK) == 0) {
      particles = particles.yxzw;
      density = density.yxzw;
    }
    if ((flags.w & SPREADING_MASK) != 0 && density.w > density.z && (flags.z & STATIC_MASK) == 0) {
      particles = particles.xywz;
      density = density.xywz;
    }
    else if ((flags.z & SPREADING_MASK) != 0 && density.z > density.w && (flags.w & STATIC_MASK) == 0) {
      particles = particles.xywz;
      density = density.xywz;
    }

    if ((flags.x & LIFTING_MASK) != 0 && density.x < density.y && (flags.y & STATIC_MASK) == 0) {
      particles = particles.yxzw;
      density = density.yxzw;
    }
    else if ((flags.y & LIFTING_MASK) != 0 && density.y < density.x && (flags.x & STATIC_MASK) == 0) {
      particles = particles.yxzw;
      density = density.yxzw;
    }
    else if ((flags.w & LIFTING_MASK) != 0 && density.w < density.z && (flags.z & STATIC_MASK) == 0) {
      particles = particles.xywz;
      density = density.xywz;
    }
    else if ((flags.z & LIFTING_MASK) != 0 && density.z < density.w && (flags.w & STATIC_MASK) == 0) {
      particles = particles.xywz;
      density = density.xywz;
    }
  }

  return particles;
}

void writeParticlesToImage(uvec4 particles, ivec2 corner) {
  imageStore(buf, corner, uvec4(particles.x));
  imageStore(buf, corner + ivec2(1, 0), uvec4(particles.y));
  imageStore(buf, corner + ivec2(0, -1), uvec4(particles.z));
  imageStore(buf, corner + ivec2(1, -1), uvec4(particles.w));
}

void writeToBlock(ivec2 texCoord, ivec2 offset) {
  uvec4 particles = simulateNeighborhood(getNeighborhood(texCoord + offset));
  writeParticlesToImage(particles, texCoord + offset);
}

void main() {
  ivec2 texCoord = ivec2(gl_LocalInvocationID * 2) + ivec2(0, 2);

  switch (iteration % 4) {
    case 0u:
      // writeParticlesToImage(uvec4(1), texCoord);
      writeToBlock(texCoord, ivec2(0,  0)); // Phase 1
      break;
    case 1u:
      // writeParticlesToImage(uvec4(2), texCoord + ivec2(1, -1));
      writeToBlock(texCoord, ivec2(1, -1)); // Phase 2
      break;
    case 2u:
      // writeParticlesToImage(uvec4(3), texCoord + ivec2(0, -1));
      writeToBlock(texCoord, ivec2(0, -1)); // Phase 3
      break;
    case 3u:
      // writeParticlesToImage(uvec4(4), texCoord + ivec2(1, 0));
      writeToBlock(texCoord, ivec2(1,  0)); // Phase 4
      break;
  }


  // imageStore(buf, texCoord, uvec4(1));
}